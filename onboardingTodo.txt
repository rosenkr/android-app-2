

2. Sweepview the video fully to see that I currently have same as he has

3. Now need to figure out how to make his code conform to my code

4. For example, he is getting a viewmodel in main activity, and passing it to AppNavigation, which passes it to the composeable OnBoardingScreen
Yes, it does need a viewmodel instance, however, in my TickersScreen and DetailScreen, they directly call viewModel = hiltViewModel()
This is cleaner instead of passing the viewmodel manually, try to conform to this style by
4.0 How does it work? notice how     viewModel: TickersViewModel = hiltViewModel()
Hilt knows which ViewModel to provie because the type is stated, its TickersViewModel in the case above!

4.1 remove the private val viewmodel in activity
4.2 modify AppNavigation so that it does not take a viewmodel
main activity calls as such:                 val navController = rememberNavController()
                                             Surface(color = MaterialTheme.colorScheme.background) {
                                                 AppNavigation(navController = navController)
                                             }
4.3 move AppNavigation outside of the onboarding package and into a new package "navigation"
4.4 Instead of having MainActivity set up the NavHost, move all code in the Surface { } block in to AppNavigation,
mix it with what is currently in Appnavigation.
4.5 HomeScreen and OnBoardingScreen will need something akin to
@Serializable
object Screen(namehere)

5. Change all objects for the screens to more telling names, instead of screenA, screenB etc...

